---
title: 蔚来数据分析面试（临时抱佛脚）
date: 2023-09-12 14:32:10
tags: 
- [Data Science]
- [面试]
categories: 
- [Python]
- [SQL]
mathjax: true
typora-root-url: ..

---

### 蔚来数据分析日常实习面试

#### 介绍一下自己的项目

介绍了在NUS做的iwallpaper项目的数据获取以及如何处理的。

#### 一个数分场景题

~~妈的，我都没听过那些名词，什么数仓异动，最后尴尬的和面试官说没学过不好意思😭~~

#### Union和Union all区别

Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；

Union All：对两个结果集进行并集操作，包括重复行，不进行排序；

#### 了解窗口函数吗，说说看呢

```sql
<窗口函数> over (partition by <用于分组的列名>
                order by <用于排序的列名>)
```

<!--more-->

#### Group by和partition by有什么区别

group by分组汇总后改变了原表行数，一行只有一个类别；

partition by分组不会减少原表行数，分组后的结果称为窗口，表示‘范围’；

#### 反问

蔚来作为传统车企和互联网企业的结合，做数分的时候有什么不同和特点呢？

### Pandas

删除所有重复的元素`drop_duplicates([""])`

查看不同的元素有多少个`len(employee["salary"].unique())`

降序排序`sort_values("salary", ascending=False)`

删除某一列`drop("id", axis=1, inplace=True)`

删除包含缺失值的行或列
`df.dropna()`

axis = 0 列 1 行

将缺失值替换为指定的值
`df.fillna(0)`

将指定值替换为新值
`df.replace('old_value', 'new_value')`

检查是否有重复的数据
`df.duplicated()`

删除重复的数据
`df.drop_duplicates()`

#### iloc和loc的区别

loc与iloc区 loc只能锁定索引和loc[]内匹配的项，

比如gplay.loc[23]查找的项必须就是gplay里面index为23的项

有的时候我们可能会把一些项提取出来，但是index还是没有变，比如我们把2，4，6项给提出另作一个DataFrame，但是仍然他们的index还是为2，4，6，这样loc[0]就不能锁定index=2的所在项，但是iloc[0]可以

iloc可以进行整数索引，loc不行

### SQL

`Left join right join inner join`区别

添加索引：加快查询速度。

防止表中有重复数据：`UNIQUE / PRIMARY KEY`

过滤重复数据：`SELECT DISTINCT`

统计重复数据：

```mysql
SELECT XX,XX,COUNT(*) FROM XXTABLE 
GROUP BY (XX,XX);
```

查询重复数据情况：

```mysql
select 列名1，列名2，count（*） as count 
from 表名
group by  列名1，列名2 
having count>1  and 其他条件;
```

窗口函数

#### **SQL中，where 和 having 的区别有哪些？**

在SQL中，where 和 having 是两个用于筛选数据的关键字，但它们的适用场景和功能略有不同。其主要区别如下：

①应用对象不同：where 用于在执行查询（即数据被检索出来）之前对数据进行过滤，作用于表的行级别；而 having 用于在执行聚合函数（即sum(),count(),avg()等）后过滤结果，作用于查询的结果集。

②聚合函数：不能直接在 where 子句中使用聚合函数，可以在 having 子句中使用聚合函数。

③查询语句：where 用于普通的 select 查询，而having只能用于group by查询。

#### **SQL中，union 和 join 的区别有哪些？**

①union：用于将两个或多个具有相同列结构的结果集合并成一个单一的结果集。结果集中不会有重复的行，即使在不同的输入结果集中有相同的行也会被合并成一个。

②join：用于在多个表之间基于某些列的关联将数据组合在一起。通过指定连接条件，可以从多个表中选择相关的数据行，将它们组合成一个更大的结果集。

#### **SQL中，count(\*) , count(字段) , count(distinct 字段)的区别是什么？**

在SQL中，count 函数用于计算满足指定条件的行数。可以以不同的方式使用，具体区别如下：

①count(*)计算所有行的数量，无论列中的值是什么。

②count(字段)计算指定列非空值的数量，不包括NULL值。

③count(dinstinct 字段)计算指定列中不同非空值的数量，排除重复的值。

#### rank，dense_rank，和row_number() 的区别

rank()是排名函数，不需要参数，因为rank函数没有参数，但需要指定按照那个字段进行排名，所以使用rank函数必须用order by参数；
over语句里面没有partition by参数，也就是整个数据视为一个窗口；
当出现名次并列时，我们使用dense_rank()函数就可以让下一个人的名次是连续的。
row_number连续排名

#### **SQL如何实现去重操作？**

SQL去重方法如下：

①DISTICT关键字：在SELECT语句中使用，可以删除所有重复行，只保留不同值。

②GROUP BY子句：通常与聚合函数一起使用，它将查询结果按指定列分组，并对每个分组进行聚合计算。如果只需要列出不同的值，可用GROUP BY子句并省略聚合函数，这样会自动去重。

③使用子查询：在SELECT语句中嵌套一个子查询，可以选择唯一的值。

④UNION操作符：合并两个或多个查询的结果集，并自动去除重复行。

以上去重方法都可能会影响查询性能，需要谨慎使用。

#### TOP N 问题

```mysql
select distinct Salary 
from 
(select dense_rank() over(order by Salary desc) num,Salary from Employee) t 
where t.num=N
```

#### 连续出现的数字

简单方法就是多表自连接，复杂方法就是找数学规律，不会(

#### **如何求出两个'yyyyMMdd'格式的日期差多少天**

```sql
select datediff(day,convert(date,'20220824',112),convert(date,'20230824',112)) from your_table;
```

#### **将'yyyy-MM-dd'的日期格式转换为'yyyyMMdd'形式**

```sql
select cast(date_column as char(8)) from your_table;
```

#### **将时间戳转换为'yyyy-MM-dd'日期格式**

```sql
select date_format(timestamp_column,'%Y-%m-%d') from your_table
```

#### 买下所有产品的客户

```mysql
select distinct customer_id
from customer 
group by customer_id
having count(distinct product_key) = (select count(*) from product)
```

### 八股

#### 一个公司上线了一个产品的功能，如何分析它的好坏

1. 定义成功指标：
   - 首先，确定产品功能的成功指标。这些指标应该与产品的目标和公司的战略一致。成功指标可能包括用户增长、用户满意度、收入增长、用户留存率等。
2. 数据收集：
   - 收集与产品功能相关的数据。这可能包括用户行为数据、用户反馈、市场份额、竞争对手的表现等。确保数据的准确性和完整性。
3. 数据清洗和处理：
4. 数据分析：
   - 使用适当的数据分析方法来评估产品功能的表现。一些常见的数据分析方法包括：
     - 描述性统计分析：计算平均值、中位数、标准差等统计指标，以了解数据的基本特征。
     - 可视化分析：创建图表和可视化来展示数据趋势和模式。
     - A/B 测试：如果可能的话，进行实验来比较不同版本的产品功能，以确定哪个版本更有效。
     - 用户行为分析：分析用户的行为路径、转化率和使用频率，以了解他们与产品功能的互动方式。
     - 用户反馈分析：分析用户的反馈和意见，了解他们的满意度和痛点。
5. 结果解释
6. 监控和反馈
7. 报告和分享

#### 事务 ACID

事务是必须满足4个条件（ACID）：`原子性`（**A**tomicity，或称不可分割性）、`一致性`（**C**onsistency）、`隔离性`（**I**solation，又称独立性）、`持久性`（**D**urability）。

### 机器学习

#### 决策树的优缺点：

优点：①易于理解和解释：决策树的模型结构类似于人类的决策过程，易于可视化和解释。

②能够处理多输出问题：决策树可以扩展到多输出问题，例如多标签分类和回归。

③能够处理缺失值：决策树可以处理具有缺失值的数据，不需要额外的处理。

缺点：①容易过拟合：决策树倾向于过度分割数据，导致过拟合问题，特别是在深树的情况下。为了缓解过拟合，可以使用剪枝技术或限制树的最大深度等方法。

②稳定性差：决策树对数据中的微小变化非常敏感，这可能导致树的结构不稳定，需要小心处理。

③处理连续性特征时可能不准确：决策树对于连续性特征的处理通常是通过阈值划分的方式，这可能导致对连续型特征的不准确建模。

④产生不平衡树：如果某个类别的样本数量远远大于其他类别，决策树可能会产生不平衡的树结构，导致对少数类别的分类性能下降。

#### 数值变量的处理方法：

①标准化（Standardization）：对数值变量进行标准化，使其均值为0，标准差为1。这可以确保不同的数值特征具有相似的尺度，有助于梯度下降等优化算法的收敛。

②归一化（Normalization）：将数值变量缩放到一个固定的范围，通常是[0,1]。这对于某些模型和距离度量可能很有用。

③对数变换（Log Transformation）：当数值变量呈现偏态分布时，可以用用对数变换来减小偏度，使其更接近正态分布。

④离散化（Discretization）：将连续的数值变量转化为离散的区间，可以帮助模型捕捉非线性关系。

#### Cluster（聚类）和Classification（分类）的区别
Cluster（聚类）和Classification（分类）是机器学习和数据分析中两个不同的任务，它们有以下区别：

1. 任务类型：
   - Cluster（聚类）是一种无监督学习任务，其目标是将数据集中的样本分组成若干个簇（群组），使得每个簇内的样本彼此相似，而不同簇之间的样本差异较大。聚类算法尝试从数据中发现隐藏的结构或模式。
   - Classification（分类）是一种监督学习任务，其目标是训练一个模型来将数据集中的样本分为已知的类别或标签之一。分类模型需要在训练过程中使用有标签的数据，并通过学习类别之间的关系来进行预测。
2. 数据需求：
   - Cluster不需要有标签的数据，它根据样本之间的相似性来组织数据。
   - Classification需要有标签的数据，每个样本都必须带有其正确的类别或标签。
3. 目标：
   - Cluster的目标是发现数据中的内在结构，通常用于数据探索和聚类分析。
   - Classification的目标是构建一个预测模型，可以用来对新样本进行分类。
4. 输出：
   - Cluster的输出是数据点的分组或簇，每个簇通常不需要一个明确的名称或标签。
   - Classification的输出是样本的类别或标签，通常是事先定义好的类别。
5. 例子：
   - 聚类的应用包括市场细分，图像分割，社交网络分析等，其中数据的类别或群组不是事先知道的。
   - 分类的应用包括垃圾邮件检测，图像识别，疾病诊断等，其中数据的类别已知，并且模型需要进行学习以进行新数据的分类。


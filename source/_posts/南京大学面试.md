---
title: 南京大学面试
date: 2023-05-22 21:28:48
tags: [面试]
---

# Python装饰器用过吗，是什么？

是的，我熟悉Python装饰器。在Python中，装饰器是一种特殊的函数，用于修改其他函数的行为。装饰器函数接受一个函数作为输入，并返回一个新的函数或修改输入函数的函数。

装饰器的语法使用`@`符号将其应用于函数，放置在被装饰的函数的定义之前。当你调用被装饰的函数时，实际上执行的是装饰器函数返回的新函数或修改后的函数。

下面是一个简单的装饰器示例，展示了如何在函数调用前后打印日志信息：

<!--more-->

```python
def log_decorator(func):
    def wrapper(*args, **kwargs):
        print("Calling function: {}".format(func.__name__))
        result = func(*args, **kwargs)
        print("Function {} executed.".format(func.__name__))
        return result
    return wrapper

@log_decorator
def add(a, b):
    return a + b

result = add(2, 3)
print(result)
```

在这个例子中，`log_decorator`是一个装饰器函数。通过使用`@log_decorator`将其应用于`add`函数，`add`函数的行为被修改了。当我们调用`add`函数时，装饰器会在函数调用前后打印日志信息。

# C++如何debug？

在C++中，有多种方法可以进行调试。下面我会介绍一些常用的调试技术和工具。

1. 使用调试器：调试器是一个强大的工具，用于逐行执行代码并观察程序状态。常见的C++调试器包括GDB（GNU调试器）和LLDB（LLVM调试器）。通过在编译时添加调试标志（如`-g`），可以生成带有调试信息的可执行文件。然后，你可以在调试器中设置断点、单步执行、观察变量的值等。
2. 打印调试信息：在关键位置插入打印语句，输出变量的值或某些特定的标识信息。你可以使用`std::cout`语句在控制台输出调试信息。但请记住，在调试完成后，要记得删除或注释掉这些打印语句，以免影响性能。
3. 使用断言（assertions）：断言是一种用于验证程序假设的工具。你可以使用`assert`宏来检查某个条件是否为真，如果条件为假，则会触发断言错误并中断程序执行。这在发现程序中的逻辑错误时很有帮助。
4. 日志记录：通过添加日志语句来记录程序的执行过程和状态。你可以使用第三方日志库，如Boost.Log、spdlog、log4cpp等，也可以自己实现一个简单的日志记录功能。日志可以在程序运行时提供有关代码流程和数据的详细信息。
5. 使用内存调试工具：内存调试工具可帮助检测和解决内存相关问题，如内存泄漏、访问越界等。例如，Valgrind是一个流行的开源内存调试工具，可以检测到许多内存错误。
6. 使用集成开发环境（IDE）：大多数流行的C++集成开发环境都提供了调试功能，如Visual Studio、CLion、Eclipse等。这些IDE通常具有图形化的调试界面，使得调试过程更加直观和方便。

# Linux命令行如何获取本地目录所有C文件的行数？

在Linux命令行中，你可以使用`find`和`wc`命令的组合来获取本地目录中所有C文件的行数。

下面是一个示例命令：

```shell
find /path/to/directory -name "*.c" -exec wc -l {} +
```

请将`/path/to/directory`替换为你要搜索的目录的实际路径。这个命令会递归地搜索指定目录下的所有以`.c`为扩展名的文件，并对每个文件使用`wc -l`命令统计行数。

执行命令后，会输出每个C文件的行数总和以及文件路径。

# grep用过吗，什么作用？

`grep`命令的一般语法如下：

```shell
grep [options] pattern [file...]
```

其中，`pattern`是你要搜索的字符串或正则表达式模式，`file`是要搜索的文件名（可以指定多个文件）。

`grep`命令的主要作用如下：

1. 搜索匹配的行：`grep`会逐行扫描文件，并返回包含匹配模式的行。
2. 支持正则表达式：`grep`可以使用正则表达式来描述更复杂的模式匹配，如通配符、字符类、重复次数等。
3. 多文件搜索：你可以同时搜索多个文件，`grep`会将匹配的行输出到标准输出。
4. 递归搜索：使用`-r`或`-R`选项，`grep`可以递归地搜索指定目录及其子目录下的文件。
5. 排除文件：使用`--exclude`或`--exclude-dir`选项，你可以排除某些文件或目录不被搜索。
6. 统计匹配数：使用`-c`选项，`grep`可以仅返回匹配到的行数，而不显示具体的匹配内容。
7. 忽略大小写：使用`-i`选项，`grep`可以忽略模式匹配时的大小写区别。

# gdb如何attach到已经运行的进程上？


要使用GDB将其附加到已经运行的进程上，可以按照以下步骤操作：

确保你已经安装了GDB。如果没有，请在Linux上使用适当的包管理器（如apt、yum或dnf）进行安装。例如，对于Ubuntu，可以使用以下命令安装GDB：

```shell
sudo apt-get install gdb
```

找到你要附加的目标进程的进程ID（PID）。你可以使用`ps`命令或其他进程监视工具来获取进程ID。例如，假设你要附加到进程名为"myapp"的进程，你可以运行以下命令来获取其进程ID：

```shell
ps aux | grep myapp
```

使用GDB的`attach`命令将其附加到目标进程。运行以下命令，将`<PID>`替换为目标进程的实际进程ID：

```shell
gdb -p <PID>
```

GDB将附加到目标进程，并显示GDB提示符，你可以在其中执行调试命令。

一旦GDB附加到目标进程，你可以设置断点、单步执行、观察变量的值等等。你可以使用GDB的各种命令来调试正在运行的进程，以帮助你分析和解决问题。

# 解释一下transformer注意力机制

在Transformer中，注意力机制主要由自注意力（Self-Attention）机制构成，它允许模型在输入序列中的不同位置之间建立关联。自注意力机制能够计算输入序列中每个位置与其他位置之间的相关性权重，从而为每个位置分配一个与其他位置的重要性相关的分数。

自注意力机制的计算过程可以分为以下几个步骤：

1. 输入表示：将输入序列中的每个元素通过线性变换映射为三个表示：查询（Query）、键（Key）和值（Value）。这些表示将用于计算注意力权重。
2. 相似性评分：通过计算查询和键之间的相似性评分，衡量查询与键的关联程度。常用的计算方法是使用点积或其他变换（如缩放点积）来计算查询和键之间的内积。
3. 注意力权重计算：将相似性评分进行归一化，以得到注意力权重。一种常见的归一化方法是使用Softmax函数，将相似性评分转化为概率分布。
4. 加权求和：使用注意力权重对值进行加权求和，得到每个位置的上下文表示。这个步骤将根据每个位置的注意力权重为不同位置提供不同的关注程度。
5. 输出表示：对加权求和的结果进行线性变换，得到最终的自注意力输出表示。

Transformer模型中的自注意力机制通过对输入序列中的元素之间的相互关系进行建模，能够捕捉到全局上下文信息，避免了传统循环神经网络中的顺序处理，并且能够处理长序列输入。这使得Transformer在自然语言处理等任务中取得了显著的成功。
